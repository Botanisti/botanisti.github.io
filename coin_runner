<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Kolikkajuoksu ‚Äî  HTML5 peli</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #0a0d12;
    color: #e7f0ff;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    overscroll-behavior: none;
    touch-action: none;
  }
  #wrap {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
  header {
    padding: 8px 12px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #10151d;
    border-bottom: 1px solid #1b2431;
    user-select: none;
  }
  header .left, header .right {
    display: flex;
    gap: 12px;
    align-items: center;
    font-size: 14px;
  }
  header .btn {
    padding: 6px 10px;
    background: #1c2533;
    border: 1px solid #2a374a;
    border-radius: 6px;
    cursor: pointer;
  }
  header .btn:active { transform: translateY(1px); }
  #game {
    flex: 1;
    display: block;
    width: 100%;
    height: 100%;
    background: radial-gradient(1000px 600px at 50% 50%, #0f1622, #070a0f);
  }
  /* Overlay panels */
  .overlay {
    position: absolute;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(5,8,12,0.72);
    backdrop-filter: blur(2px);
  }
  .overlay.show { display: flex; }
  .panel {
    background: #0f1622;
    border: 1px solid #24344a;
    border-radius: 12px;
    padding: 16px;
    width: min(92vw, 720px);
    box-shadow: 0 10px 40px rgba(0,0,0,0.35);
  }
  .panel h1, .panel h2 { margin: 0 0 8px; }
  .panel p { margin: 6px 0; line-height: 1.4; }
  .row { display: flex; gap: 10px; flex-wrap: wrap; }
  .grow { flex: 1 1 auto; }
  .shop-item {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 6px 12px;
    align-items: center;
    padding: 10px;
    border: 1px solid #24344a;
    border-radius: 10px;
    background: #0b121b;
  }
  .shop-item h3 { margin: 0; font-size: 16px; }
  .muted { color: #9cb3d0; font-size: 13px; }
  .tag { font-size: 12px; padding: 2px 6px; border-radius: 999px; background: #172233; border: 1px solid #2a3a52; }
  .buy {
    padding: 8px 12px; border-radius: 8px; border: 1px solid #2a3a52; background: #172233; cursor: pointer;
  }
  .buy[disabled] { opacity: 0.5; cursor: not-allowed; }
  .footer {
    display: flex; justify-content: space-between; align-items: center; margin-top: 12px;
  }
  /* Mobile controls */
  #touchControls {
    position: absolute;
    inset: 0;
    pointer-events: none; /* child buttons override */
  }
  .stickZone {
    position: absolute;
    left: 12px; bottom: 12px;
    width: 40vw; max-width: 260px; height: 40vw; max-height: 260px;
    border-radius: 50%;
    background: rgba(255,255,255,0.03);
    border: 1px dashed rgba(255,255,255,0.08);
    pointer-events: auto;
  }
  .stick {
    position: absolute;
    left: 50%; top: 50%;
    width: 64px; height: 64px;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    background: rgba(120,180,255,0.16);
    border: 1px solid rgba(120,180,255,0.35);
  }
  .actionBtn {
    position: absolute;
    right: 16px; bottom: 28px;
    width: 70px; height: 70px;
    border-radius: 50%;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.12);
    pointer-events: auto;
    display: grid; place-items: center;
    user-select: none;
  }
  .actionBtn span { font-size: 13px; color: #cfe3ff; }
  @media (min-width: 900px) {
    .stickZone { display: none; }
    .actionBtn { display: none; }
  }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="left">
      <strong>Kolikkajuoksu</strong>
      <div id="hudCoins">üí∞ 0</div>
      <div id="hudScore">‚≠ê 0</div>
      <div id="hudStage" class="tag">Taso 1</div>
    </div>
    <div class="right">
      <div class="btn" id="btnPause">Tauko</div>
      <div class="btn" id="btnShop">Kauppa</div>
      <div class="btn" id="btnReset">Uusi juoksu</div>
    </div>
  </header>
  <canvas id="game"></canvas>
</div>

<!-- Overlays -->
<div class="overlay" id="overlayStart">
  <div class="panel">
    <h1>Kolikkajuoksu</h1>
    <p>Ker√§√§ kolikoita. Kun rahaa on tarpeeksi, peli siirtyy <strong>Tasolle 2</strong>, jossa ilmestyy vihollisia. V√§lttele tai k√§yt√§ powerup‚Äëkykyj√§. Peli on <em>endless</em> ja loppuu, kun saat osuman.</p>
    <p>Kolikot muuttuvat kierroksen p√§√§tytty√§ pysyv√§ksi valuutaksi, jolla voit ostaa <strong>parannuksia</strong> seuraavia juoksuja varten.</p>
    <div class="footer">
      <div class="muted">Ohjaus: Nuolin√§pp√§imet / WASD / kosketus. Ampuaksesi napauta / v√§lily√∂nti.</div>
      <button class="buy" id="btnStart">Aloita</button>
    </div>
  </div>
</div>

<div class="overlay" id="overlayGameOver">
  <div class="panel">
    <h2>Peli ohi</h2>
    <p id="goStats"></p>
    <div class="footer">
      <div class="muted">Kolikot lis√§tty pysyv√§√§n kassaan.</div>
      <div class="row">
        <button class="buy" id="btnGoShop">Kauppaan</button>
        <button class="buy" id="btnGoRestart">Uusi juoksu</button>
      </div>
    </div>
  </div>
</div>

<div class="overlay" id="overlayShop">
  <div class="panel">
    <h2>Kauppa</h2>
    <p>Pysyv√§t p√§ivitykset vaikuttavat kaikkiin tuleviin juoksuihin.</p>
    <p id="bank">Kassa: 0üí∞</p>
    <div class="row" id="shopList"></div>
    <div class="footer">
      <div class="muted">P√§ivitykset tallennetaan paikallisesti (localStorage).</div>
      <button class="buy" id="btnCloseShop">Takaisin peliin</button>
    </div>
  </div>
</div>

<div id="touchControls">
  <div class="stickZone" id="stickZone"><div class="stick" id="stick"></div></div>
  <div class="actionBtn" id="fireBtn"><span>FIRE</span></div>
</div>

<script>
// ---------- Utility ----------
const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
const rand = (a, b) => Math.random() * (b - a) + a;
const dist2 = (ax, ay, bx, by) => {
  const dx = ax - bx, dy = ay - by;
  return dx*dx + dy*dy;
};

// ---------- Persistent meta (shop) ----------
const DEFAULT_META = {
  bank: 0,                 // persistent coins
  upgrades: {
    speed: 0,              // +0..+5
    fireRate: 0,           // +0..+5
    magnet: 0,             // +0..+5
    shield: 0              // +0..+5 (starts with chance to spawn shield at start)
  }
};
function loadMeta() {
  try {
    const raw = localStorage.getItem("coinrunner_meta");
    if (!raw) return structuredClone(DEFAULT_META);
    const data = JSON.parse(raw);
    // sanity
    if (!data.upgrades) data.upgrades = structuredClone(DEFAULT_META.upgrades);
    return data;
  } catch(e) {
    console.warn("meta load failed", e);
    return structuredClone(DEFAULT_META);
  }
}
function saveMeta() {
  localStorage.setItem("coinrunner_meta", JSON.stringify(meta));
}
let meta = loadMeta();

// ---------- Game state ----------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha: false });
let W = 0, H = 0, DPR = 1;
function resize() {
  DPR = window.devicePixelRatio || 1;
  W = Math.floor(window.innerWidth * DPR);
  H = Math.floor((window.innerHeight - document.querySelector("header").offsetHeight) * DPR);
  canvas.width = W;
  canvas.height = H;
  canvas.style.width = (W / DPR) + "px";
  canvas.style.height = (H / DPR) + "px";
}
window.addEventListener("resize", resize);

const hudCoins = document.getElementById("hudCoins");
const hudScore = document.getElementById("hudScore");
const hudStage = document.getElementById("hudStage");

let playing = false;
let paused = false;
let stage = 1;                 // 1 = collect, 2 = enemies
let score = 0;
let runCoins = 0;
let totalTime = 0;
let enemySpawnTimer = 0;
let coinSpawnTimer = 0;
let bullets = [];
let enemies = [];
let coins = [];
let effects = [];
let player;
let keys = {};
let lastTs = 0;
let toStage2At = 30;           // coins needed to open stage 2 (scaled by upgrades)

// temporary powerups in-run
let tempPower = {
  magnet: 0,       // seconds left
  rapid: 0,        // seconds left
  shield: 0        // hit protection
};

// ---------- Player ----------
function newPlayer() {
  const baseSpeed = 200; // px/s
  const speedBonus = meta.upgrades.speed * 18;
  const p = {
    x: W/2, y: H/2,
    r: 12 * DPR,
    speed: (baseSpeed + speedBonus) * DPR,
    fireCd: 0,
    fireInterval: Math.max(0.12, 0.30 - meta.upgrades.fireRate * 0.035), // s
    alive: true
  };
  // chance to start with shield based on upgrade level
  if (meta.upgrades.shield > 0 && Math.random() < meta.upgrades.shield * 0.12) {
    tempPower.shield = 1;
  }
  return p;
}

// ---------- Entities ----------
function spawnCoin(x = rand(20, W-20), y = rand(20, H-20)) {
  coins.push({ x, y, r: 8*DPR, vx: 0, vy: 0, magnet: false });
}
function spawnEnemy() {
  const side = Math.floor(rand(0,4));
  const margin = 30 * DPR;
  let x = 0, y = 0;
  if (side === 0) { x = rand(0, W); y = -margin; }
  if (side === 1) { x = W+margin; y = rand(0, H); }
  if (side === 2) { x = rand(0, W); y = H+margin; }
  if (side === 3) { x = -margin; y = rand(0, H); }
  const speed = rand(60, 120) * DPR;
  enemies.push({
    x, y, r: 16*DPR, speed,
    angle: Math.atan2(player.y - y, player.x - x),
    hp: 1
  });
}
function shoot() {
  if (!player.alive) return;
  const now = performance.now();
  if (player.fireCd > 0) return;
  const spread = tempPower.rapid > 0 ? 0.12 : 0.06;
  const bulletCount = tempPower.rapid > 0 ? 3 : 1;
  const speed = 480 * DPR;
  for (let i=0;i<bulletCount;i++) {
    const a = Math.atan2(aim.dy, aim.dx) + (i - (bulletCount-1)/2) * spread;
    bullets.push({ x: player.x, y: player.y, vx: Math.cos(a)*speed, vy: Math.sin(a)*speed, r: 4*DPR, life: 1.4 });
  }
  player.fireCd = player.fireInterval * (tempPower.rapid>0 ? 0.55 : 1);
  effects.push({ type:"muzzle", x: player.x, y: player.y, t: 0 });
}

// ---------- Input ----------
const aim = { dx: 1, dy: 0 }; // default aim right
document.addEventListener("keydown", (e)=>{
  if (e.repeat) return;
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," ","Space","w","a","s","d","W","A","S","D"].includes(e.key)) e.preventDefault();
  keys[e.key.toLowerCase()] = true;
  if (e.key === " " || e.key === "Spacebar") shoot();
  if (e.key === "p") togglePause();
});
document.addEventListener("keyup",(e)=>{ keys[e.key.toLowerCase()] = false; });

// Mouse aim + click fire
canvas.addEventListener("mousemove", (e)=>{
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * DPR;
  const my = (e.clientY - rect.top) * DPR;
  aim.dx = mx - player.x;
  aim.dy = my - player.y;
});
canvas.addEventListener("mousedown", (e)=>{ shoot(); });

// Touch controls: virtual stick + fire button
const stickZone = document.getElementById("stickZone");
const stick = document.getElementById("stick");
const fireBtn = document.getElementById("fireBtn");
let stickActive = false, stickId = null, stickCenter = {x:0,y:0};
function setStick(x, y) {
  stick.style.left = x + "px";
  stick.style.top = y + "px";
}
function touchPos(ev, t) {
  const rect = stickZone.getBoundingClientRect();
  return { x: t.clientX - rect.left, y: t.clientY - rect.top, rect };
}
stickZone.addEventListener("touchstart", (ev)=>{
  const t = ev.changedTouches[0];
  stickActive = true; stickId = t.identifier;
  const p = touchPos(ev, t);
  stickCenter = { x: p.x, y: p.y };
  setStick(p.x, p.y);
});
stickZone.addEventListener("touchmove", (ev)=>{
  if (!stickActive) return;
  for (const t of ev.changedTouches) if (t.identifier === stickId) {
    const p = touchPos(ev, t);
    const dx = p.x - stickCenter.x, dy = p.y - stickCenter.y;
    const maxR = 70;
    const len = Math.hypot(dx, dy) || 1;
    const ux = dx/len, uy = dy/len;
    const mag = Math.min(maxR, len);
    setStick(stickCenter.x + ux*mag, stickCenter.y + uy*mag);
    // map to velocity each frame via global stickVec
    stickVec.x = (dx / maxR);
    stickVec.y = (dy / maxR);
  }
});
stickZone.addEventListener("touchend", (ev)=>{
  for (const t of ev.changedTouches) if (t.identifier === stickId) {
    stickActive = false; stickId = null; stickVec.x = 0; stickVec.y = 0;
    setStick(stickCenter.x, stickCenter.y);
  }
});
fireBtn.addEventListener("touchstart", (ev)=>{ shoot(); });

const stickVec = { x: 0, y: 0 };

// ---------- Overlays ----------
const overlayStart = document.getElementById("overlayStart");
const overlayGo = document.getElementById("overlayGameOver");
const overlayShop = document.getElementById("overlayShop");
document.getElementById("btnStart").onclick = ()=>{ startRun(); };
document.getElementById("btnGoShop").onclick = ()=>{ openShop(); };
document.getElementById("btnGoRestart").onclick = ()=>{ overlayGo.classList.remove("show"); startRun(); };
document.getElementById("btnPause").onclick = ()=> togglePause();
document.getElementById("btnShop").onclick = ()=> openShop();
document.getElementById("btnReset").onclick = ()=> startRun();

function togglePause() {
  if (!playing) return;
  paused = !paused;
  document.getElementById("btnPause").textContent = paused ? "Jatka" : "Tauko";
}

function openShop() {
  updateShop();
  overlayShop.classList.add("show");
}
document.getElementById("btnCloseShop").onclick = ()=> overlayShop.classList.remove("show");

// ---------- Shop ----------
const shopDefinition = [
  { key: "speed",    name: "Liikkumisnopeus", desc: "Nopeampi liike.", base: 80, step: 60, max: 5 },
  { key: "fireRate", name: "Tulinopeus",      desc: "Ammu useammin.", base: 100, step: 70, max: 5 },
  { key: "magnet",   name: "Magneetti",       desc: "Kolikot vet√§ytyv√§t l√§hemm√§s.", base: 120, step: 80, max: 5 },
  { key: "shield",   name: "Alkusuoja",       desc: "Mahd. saada suojakilpi juoksun alkuun.", base: 150, step: 90, max: 5 }
];
function priceFor(upKey, level) {
  const def = shopDefinition.find(d=>d.key===upKey);
  return Math.round(def.base + def.step * level);
}
function updateShop() {
  document.getElementById("bank").textContent = "Kassa: " + meta.bank + "üí∞";
  const list = document.getElementById("shopList");
  list.innerHTML = "";
  for (const def of shopDefinition) {
    const lv = meta.upgrades[def.key] || 0;
    const maxed = lv >= def.max;
    const price = priceFor(def.key, lv);
    const div = document.createElement("div");
    div.className = "shop-item grow";
    div.innerHTML = `
      <div>
        <h3>${def.name} <span class="tag">Taso ${lv}/${def.max}</span></h3>
        <div class="muted">${def.desc}</div>
      </div>
      <div>
        <button class="buy" ${maxed?"disabled":""} data-key="${def.key}">${maxed?"Max":("Osta "+price+"üí∞")}</button>
      </div>
    `;
    list.appendChild(div);
  }
  list.querySelectorAll("button.buy").forEach(btn=>{
    btn.onclick = ()=>{
      const key = btn.getAttribute("data-key");
      const lv = meta.upgrades[key];
      const price = priceFor(key, lv);
      if (meta.bank >= price && lv < shopDefinition.find(d=>d.key===key).max) {
        meta.bank -= price;
        meta.upgrades[key]++;
        saveMeta();
        updateShop();
      }
    };
  });
}

// ---------- Game Flow ----------
function startRun() {
  overlayStart.classList.remove("show");
  overlayGo.classList.remove("show");
  overlayShop.classList.remove("show");
  playing = true; paused = false;
  stage = 1;
  score = 0;
  runCoins = 0;
  totalTime = 0;
  player = newPlayer();
  bullets = [];
  enemies = [];
  coins = [];
  effects = [];
  enemySpawnTimer = 0;
  coinSpawnTimer = 0;
  // coin threshold scales down with magnet upgrade to help reach stage 2 earlier slightly
  toStage2At = Math.max(10, 30 - meta.upgrades.magnet * 2);
  // seed some coins
  for (let i=0;i<10;i++) spawnCoin();
  document.getElementById("btnPause").textContent = "Tauko";
}
function gameOver() {
  playing = false;
  paused = false;
  meta.bank += runCoins;
  saveMeta();
  document.getElementById("goStats").textContent =
    `Pisteet: ${Math.floor(score)} ‚≠ê ‚Äî Kolikot: ${runCoins} üí∞ ‚Äî Aika: ${Math.floor(totalTime)} s`;
  overlayGo.classList.add("show");
}

// ---------- Update/Render ----------
function update(dt) {
  if (!playing || paused) return;
  totalTime += dt;
  // Input vector
  let vx = 0, vy = 0;
  if (keys["arrowup"] || keys["w"]) vy -= 1;
  if (keys["arrowdown"] || keys["s"]) vy += 1;
  if (keys["arrowleft"] || keys["a"]) vx -= 1;
  if (keys["arrowright"] || keys["d"]) vx += 1;
  // add stick
  vx += stickVec.x;
  vy += stickVec.y;
  const len = Math.hypot(vx, vy);
  if (len > 0) { vx /= len; vy /= len; }
  // move player
  player.x = clamp(player.x + vx * player.speed * dt, 10, W-10);
  player.y = clamp(player.y + vy * player.speed * dt, 10, H-10);

  // cooldowns
  if (player.fireCd > 0) player.fireCd -= dt;
  if (tempPower.magnet > 0) tempPower.magnet -= dt;
  if (tempPower.rapid > 0) tempPower.rapid -= dt;

  // spawn coins
  coinSpawnTimer -= dt;
  const targetCoinCount = 20;
  if (coinSpawnTimer <= 0 && coins.length < targetCoinCount) {
    spawnCoin();
    coinSpawnTimer = rand(0.3, 0.9);
  }

  // stage progression
  if (stage === 1 && runCoins >= toStage2At) {
    stage = 2;
    hudStage.textContent = "Taso 2";
    effects.push({ type:"flash", t:0 });
  }

  // spawn enemies (stage 2)
  if (stage === 2) {
    enemySpawnTimer -= dt;
    if (enemySpawnTimer <= 0) {
      spawnEnemy();
      enemySpawnTimer = Math.max(0.25, 1.2 - Math.min(40, totalTime) * 0.02);
    }
  }

  // enemy AI
  for (const e of enemies) {
    const ang = Math.atan2(player.y - e.y, player.x - e.x);
    e.x += Math.cos(ang) * e.speed * dt;
    e.y += Math.sin(ang) * e.speed * dt;
  }

  // bullets
  for (let i=bullets.length-1;i>=0;i--) {
    const b = bullets[i];
    b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
    if (b.life <= 0 || b.x< -20 || b.x>W+20 || b.y<-20 || b.y>H+20) bullets.splice(i,1);
  }

  // collisions: bullets vs enemies
  for (let i=enemies.length-1;i>=0;i--) {
    const e = enemies[i];
    for (let j=bullets.length-1;j>=0;j--) {
      const b = bullets[j];
      if (dist2(e.x,e.y,b.x,b.y) < (e.r+b.r)*(e.r+b.r)) {
        bullets.splice(j,1);
        e.hp -= 1;
        if (e.hp <= 0) {
          effects.push({ type:"boom", x:e.x, y:e.y, t:0 });
          enemies.splice(i,1);
          score += 15;
        }
        break;
      }
    }
  }

  // coins magnet & pickup
  const magnetRadius = (60 + meta.upgrades.magnet*18) * DPR * (tempPower.magnet>0 ? 1.8 : 1);
  for (let i=coins.length-1;i>=0;i--) {
    const c = coins[i];
    const d2 = dist2(player.x, player.y, c.x, c.y);
    if (d2 < (player.r + c.r)*(player.r + c.r)) {
      coins.splice(i,1);
      runCoins += 1;
      score += 5;
      // drop chance for temporary powerup
      if (Math.random() < 0.08) {
        const roll = Math.random();
        if (roll < 0.34) tempPower.magnet = 6;
        else if (roll < 0.68) tempPower.rapid = 5;
        else tempPower.shield = 1;
      }
      continue;
    }
    if (d2 < magnetRadius*magnetRadius) {
      const d = Math.sqrt(d2) || 1;
      const ux = (player.x - c.x)/d, uy = (player.y - c.y)/d;
      const pull = 120 * DPR * dt;
      c.x += ux * pull;
      c.y += uy * pull;
    }
  }

  // enemies vs player
  for (let i=enemies.length-1;i>=0;i--) {
    const e = enemies[i];
    if (dist2(e.x,e.y,player.x,player.y) < (e.r+player.r)*(e.r+player.r)) {
      if (tempPower.shield > 0) {
        tempPower.shield = 0;
        effects.push({ type:"shield", x: player.x, y: player.y, t:0 });
        enemies.splice(i,1);
      } else {
        gameOver();
        break;
      }
    }
  }

  // HUD
  hudCoins.textContent = "üí∞ " + runCoins;
  hudScore.textContent = "‚≠ê " + Math.floor(score);
}

function render(dt) {
  // background
  ctx.fillStyle = "#0b111a";
  ctx.fillRect(0,0,W,H);

  // parallax grid
  const grid = 60 * DPR;
  ctx.strokeStyle = "rgba(120,160,220,0.06)";
  ctx.lineWidth = 1 * DPR;
  ctx.beginPath();
  for (let x = (performance.now()*0.02) % grid; x < W; x += grid) {
    ctx.moveTo(x,0); ctx.lineTo(x,H);
  }
  for (let y = (performance.now()*0.014) % grid; y < H; y += grid) {
    ctx.moveTo(0,y); ctx.lineTo(W,y);
  }
  ctx.stroke();

  // coins
  for (const c of coins) {
    const g = ctx.createRadialGradient(c.x, c.y, 1, c.x, c.y, c.r);
    g.addColorStop(0, "#ffe58a");
    g.addColorStop(1, "#c38a1c");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
    ctx.fill();
  }

  // enemies
  ctx.fillStyle = "#ff5b6f";
  for (const e of enemies) {
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
    ctx.fill();
    // eye
    ctx.fillStyle = "#2b0b10";
    ctx.beginPath();
    ctx.arc(e.x + e.r*0.25, e.y - e.r*0.25, e.r*0.35, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "#ff5b6f";
  }

  // bullets
  ctx.fillStyle = "#aee1ff";
  for (const b of bullets) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fill();
  }

  // player
  // body
  ctx.fillStyle = "#7bd7ff";
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
  ctx.fill();
  // direction eye
  const ang = Math.atan2(aim.dy, aim.dx);
  ctx.fillStyle = "#0b2030";
  ctx.beginPath();
  ctx.arc(player.x + Math.cos(ang)*player.r*0.45, player.y + Math.sin(ang)*player.r*0.45, player.r*0.4, 0, Math.PI*2);
  ctx.fill();

  // powerup auras
  if (tempPower.magnet > 0) {
    ctx.strokeStyle = "rgba(120,200,255,0.25)";
    ctx.lineWidth = 2*DPR;
    ctx.beginPath();
    ctx.arc(player.x, player.y, (60 + meta.upgrades.magnet*18) * DPR * 0.6, 0, Math.PI*2);
    ctx.stroke();
  }
  if (tempPower.shield > 0) {
    ctx.strokeStyle = "rgba(180,255,220,0.45)";
    ctx.lineWidth = 3*DPR;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r + 6*DPR, 0, Math.PI*2);
    ctx.stroke();
  }

  // effects
  for (let i=effects.length-1;i>=0;i--) {
    const e = effects[i];
    e.t += dt;
    if (e.type === "muzzle") {
      ctx.strokeStyle = "rgba(150,220,255,0.5)";
      ctx.lineWidth = 2 * DPR;
      ctx.beginPath();
      ctx.arc(e.x, e.y, 12*DPR * (1+e.t*3), 0, Math.PI*2);
      ctx.stroke();
      if (e.t > 0.15) effects.splice(i,1);
    } else if (e.type === "boom") {
      ctx.strokeStyle = "rgba(255,120,150,0.5)";
      ctx.lineWidth = 2 * DPR;
      ctx.beginPath();
      ctx.arc(e.x, e.y, 10*DPR + 60*DPR*e.t, 0, Math.PI*2);
      ctx.stroke();
      if (e.t > 0.3) effects.splice(i,1);
    } else if (e.type === "flash") {
      ctx.fillStyle = "rgba(255,255,255," + (0.5 - e.t) + ")";
      ctx.fillRect(0,0,W,H);
      if (e.t > 0.5) effects.splice(i,1);
    } else if (e.type === "shield") {
      ctx.strokeStyle = "rgba(180,255,220," + (0.9 - e.t) + ")";
      ctx.lineWidth = 3 * DPR;
      ctx.beginPath();
      ctx.arc(e.x, e.y, 24*DPR + e.t*60*DPR, 0, Math.PI*2);
      ctx.stroke();
      if (e.t > 0.4) effects.splice(i,1);
    }
  }
}

function loop(ts) {
  if (!lastTs) lastTs = ts;
  const dt = Math.min(0.033, (ts - lastTs) / 1000);
  lastTs = ts;
  update(dt);
  render(dt);
  requestAnimationFrame(loop);
}

// ---------- Boot ----------
resize();
overlayStart.classList.add("show");
hudStage.textContent = "Taso 1";
requestAnimationFrame(loop);
</script>
</body>
</html>
